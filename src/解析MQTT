客户端创建层次:

mqtt_client			MQTTClients										Clients
一个客户实体			一个实体中主要的记录元素				偏重于客户端本地的信息,前面偏重客户端对应的服务器信息
一个客户端就能创建一个,除非整个重开始


链接:
上面一个客户端可以同时创建几个套接字链接到几个不同的服务器上.
TCP/IP上的连接等待并没有使用线程等待,而仅仅是阻塞等待的.

前面的TCP/IP连接和协议层连接都直接使用了阻塞方式,一步步向下走的.


MQTTClient_run
connectionLost_call		---目前作为回调函数并没有使用



MQTTProtocol_connect  ---继续
connect_pending

MQTTClient_waitfor


MQTTClient_cycle  ---这样的函数是最终需要周期执行的
MQTTClient_retry

发送:
MQTTClient_yield

程序整体框架:
一个主线程实现所有功能,当需要的时候可以通过信号量之类的实现阻塞等待,也可以运行一个线程实现周期处理函数,如果不运行这样一个线程
可以把周期处理函数放在主线程中调用.

2016/11/30 23:53:25


2016/12/1 星期四 下午 5:17:33
套接字的操作:
---写
最底层	writev
写处理	Socket_continueWrites
检查		Socket_getReadySocket		//-这是关键的一步,检查是否需要处理套接字
周期调用MQTTClient_cycle

最底层	writev
Socket_putdatas
MQTTPacket_sends	/	MQTTPacket_send
MQTTPacket_send_publish
//-上面两个地方实现了套接字的写操作,前面一个是周期性的把悬挂缓冲区的内容发送出去,后面一个是主动启动一次发送.

---读
最底层	recv
Socket_getch
MQTTPacket_decode	/	Socket_getdata	
MQTTPacket_Factory
MQTTClient_cycle

最底层	recv
Socket_close
MQTTClient_closeSession
//-读数据主要还是在周期函数里面实现的,有一个关闭的时候应该就是完成剩余的工作,而不是调周期函数


首先查询套接字是否空闲可用(在链表中顺查找),优先把没有发送出去的都发送出去(里面有一个循环),然后如果有可读的就进行读操作,这样周而复始.
发送出内容后,等待应答的时候,就周期调用上面的处理过程.接收信息也是周期执行上面的处理过程.




2016/11/27 16:55:28
从现在开始带着问题去解读程序.

2016/12/2 星期五 上午 9:52:44
s.clientsds

2016/12/7 22:21:02
今天解决了红黑树,以后不再专门看他除非实际有什么作用.

2016/12/8 星期四 下午 1:30:24
发送的消息首先会被存在在一个输出队列中,然后如果发送不成功的话会增加队列控制,完成了空间就可以释放了
接收订阅,套接字接收到内容后就存储起来,在整个消息的传递过程中就通过链表来定位到这个最原始的地方.

2016/12/9 星期五 上午 9:15:11
持久存储首先在创建客户端的时候就开辟了.
持久存储其实本质就是写入到非易失性存储器中,这里采用这样的逻辑:客户可以指定处理方式,
系统默认提供了读写文件的方法,就是创建一个文件来记录信息.

2016/12/12 星期一 上午 8:54:39
这里的head应该可以这样理解,就是自己开辟了一个空间,然后以空间的指针值建立一个树(树的key就是首地址值),通过这个结构可以很好
的进行定位,堆其实就是自己组织的一个空间,仅仅是这个空间具有可追溯性(用树结构实现的),然后可以更准确的操作(比如查看内存是否
实际泄露),空间内容的使用由具体应用决定,堆仅仅是维护这个空间.














整体理解概述:
套接字是可以建立多个的在一个客户端


功能点:
1.如何实现有内容就发,没有内容发ping帧的.
在周期函数MQTTClient_cycle中,每次都判断下是否需要发送ping帧了

2.整个套接字的运行机制.

3.深入了解链表和队列在协议栈中的使用

4.消息在发布的时候在协议栈中存储的模式,接收的消息在协议栈中存储的模式.

5.持久存储








