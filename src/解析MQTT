客户端创建层次:

mqtt_client			MQTTClients										Clients
一个客户实体			一个实体中主要的记录元素				偏重于客户端本地的信息,前面偏重客户端对应的服务器信息
一个客户端就能创建一个,除非整个重开始


链接:
上面一个客户端可以同时创建几个套接字链接到几个不同的服务器上.
TCP/IP上的连接等待并没有使用线程等待,而仅仅是阻塞等待的.

前面的TCP/IP连接和协议层连接都直接使用了阻塞方式,一步步向下走的.


MQTTClient_run
connectionLost_call		---目前作为回调函数并没有使用



MQTTProtocol_connect  ---继续
connect_pending

MQTTClient_waitfor


MQTTClient_cycle  ---这样的函数是最终需要周期执行的
MQTTClient_retry

发送:
MQTTClient_yield

程序整体框架:
一个主线程实现所有功能,当需要的时候可以通过信号量之类的实现阻塞等待,也可以运行一个线程实现周期处理函数,如果不运行这样一个线程
可以把周期处理函数放在主线程中调用.

2016/11/30 23:53:25


2016/12/1 星期四 下午 5:17:33
套接字的操作:
---写
最底层	writev
写处理	Socket_continueWrites
检查		Socket_getReadySocket
周期调用MQTTClient_cycle

最底层	writev
Socket_putdatas
MQTTPacket_sends	/	MQTTPacket_send
MQTTPacket_send_publish
//-上面两个地方实现了套接字的写操作,前面一个是周期性的把悬挂缓冲区的内容发送出去,后面一个是主动启动一次发送.

---读
最底层	recv
Socket_getch
MQTTPacket_decode	/	Socket_getdata	
MQTTPacket_Factory
MQTTClient_cycle

最底层	recv
Socket_close
MQTTClient_closeSession
//-读数据主要还是在周期函数里面实现的,有一个关闭的时候应该就是完成剩余的工作,而不是调周期函数







2016/11/27 16:55:28
从现在开始带着问题去解读程序.





功能点:
1.如何实现有内容就发,没有内容发ping帧的.
在周期函数MQTTClient_cycle中,每次都判断下是否需要发送ping帧了

2.整个套接字的运行机制.


